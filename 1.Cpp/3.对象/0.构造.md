#### 构造

对于`const`对象，只有当构造函数结束后，其才具有`const`属性。所以在构造函数中，可以对`const`对象进行写值操作。

构造对象的过程：
1. 为该对象分配一块空间。
2. 如果空间地址不为`nullptr`，调用构造函数初始化这块空间。

---

#### 默认构造函数

不需要参数、或所有参数都具有默认值的构造函数，就是默认构造函数。

类可以定义多个默认构造函数。但如果使用默认构造的方式创建对象，将报错。

---

#### 合成构造函数

当编译器需要默认构造函数，但未定义时，编译器会自动合成一个默认构造函数。以下情况会合成默认构造：
1. 对象成员具有默认构造函数（包含合成的默认构造）。
2. 基类具有默认构造函数。
3. 具有虚函数（编译器需要插入代码，以初始化虚指针）。
4. 继承链中有虚继承（编译器需要插入代码，以初始化虚基类指针）。
5. 使用`=default`显示让编译器合成。

合成的构造函数不会初始化内置类型和复合类型成员。

---

#### 初始化列表

只有在初始化列表中进行的才是初始化操作，构造函数体中的操作属于赋值。所以常量成员只能在初始化列表中进行初始化。

初始化列表只负责初始化的值，初始化顺序与在类中定义的顺序一致。

---

#### 委托构造

在初始化列表中可以调用自身或基类的构造函数，且使用委托调用后，初始化列表中只能存在该调用作为唯一的成员初始化器。

循环调用委托构造属于未定义行为，且编译器不一定会做检测。

---

#### 转换构造函数

可以只接受一个参数的构造函数，定义了将其他类型数据转换为该类的机制。默认支持隐式转换，使用`explicit`关键字，只支持显示调用。

对于隐式转换，编译器只会进行一步转换。

```cpp
struct A
{
    A(int) {}
};

struct B
{
    B(A) {}
};

int main()
{
    B b1 = 1;		// 隐式转换失败
    B b2(1);		// 显示转换成功
    return 0;
}
```


---

#### 继承构造函数

在派生类中使用`using`声明基类的构造函数，当派生类中不存在基类构造函数参数匹配的构造函数时，编译器将会合成与基类构造函数参数匹配的构造函数。

该声明不会改变构造函数的访问权限。

```cpp
struct Base
{
    Base(int)
    {
        std::cout << "Base(int)" << std::endl;
    }
};

struct Derive
{
    using Base::Base;
};

int main()
{
    Derive(0); // Base(int)
    return 0;
}
```
