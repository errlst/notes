###### 定义

concept是c++20引入用于约束模板类型的语法糖，其定义形式如下：

```cpp
template <template_list>
concept concept_name = concept_expression;
```

其中concept_expression是编译期可确定的布尔表达式或约束表达式。

concept本质上是编译期布尔常量，可直接作为布尔常量使用。

###### 使用

c++委员会定义了多种使用concept的方式：

* 基本的函数模板约束。

  ```cpp
  template <std::integral T> 
  auto call(T t) -> void;
  ```

* 配合requires进行约束。

  ```cpp
  template <typename T>
      requires std::integral<T>
  auto call(T t) -> void;
  ```

* requires置于其它位置。

  ```cpp
  template <typename T>
  auto call(T t) -> void
      requires std::integral<T>;
  ```

* 配合auto进行约束。

  ```cpp
  auto call(std::integral auto t) -> void;
  ```

concept除了用于约束参数类型，还可约束auto变量。

```cpp
std::integral auto val{0};
```

###### 约束

在某些情况下，concept的需求相对较为复杂，此时可使用requires约束表达式。其定义形式如下：

```cpp
template<typename_list>
concept concept_name = requires (parameter_list) {require_list};
```

其中parameter_list是可选的参数列表，require_list是由多个约束构成的约束表达式。

约束可以分为以下几种类型：

* 简单约束。

  简单约束就是单个表达式，编译期会对表达式进行合法性检测。

  ```cpp
  // 可调用，且可接受单个int参数
  template <typename T>
  concept callable_with_int_argument = requires(const T &t) { t(0); };
  ```

* 类型约束。

  在typename后跟上类型，编译期会判断该类型进行合法性检测。

  ```cpp
  // 拥有type嵌套类型
  template <typename T>
  concept has_type = requires { typename T::type; };
  ```

* 复合约束。

  复合约束用于约束表达式的返回类型，其基本形式为`{expr} -> type_constraint`，type_constraint必须是类型约束，而不是类型。

  ```cpp
  // int指针
  template <typename T>
  concept int_ptr = requires (T t){{*t} -> std::same_as<int>;};
  ```

* 嵌套约束。

  在requires内部使用`resuires constraint_expression`进行嵌套约束。

###### 标准库

c++标准库在\<concept\>头文件中定义了一些常用的concept。

* `std::same_as<T, U>`，两个类型相等时概念满足，如果可以通过上下文推断需要比较的另一个类型，此时可以只传入一个类型。
* `std::integral<T>`，类型是整数时概念满足。
* `std::floating_point<T>`，类型是浮点时概念满足。
* `std::default_initializable<T>`，类型可默认初始化时概念满足。

