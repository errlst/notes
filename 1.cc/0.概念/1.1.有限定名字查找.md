如果`::`左侧为空，那么只会在全局命名空间作用域中（包括通过using声明引入全局命名空间中的）查找声明。

```cpp
auto main() -> int {
	struct std {};

	std::cout << "error\n";	// 对std的无限定查找匹配到结构体
	::std::cout << "true\n";

	return 0;
}
```

当限定名是[声明符](https://zh.cppreference.com/w/cpp/language/declarations)时，对同一声明符中随该限定名之后的[无限定查找]()，在对应类或命名空间的作用域中进行。

```cpp
constexpr int size = 100;

struct T {
    static constexpr int size = 50;
    static std::vector<int> arr;
};

std::vector<int> T::arr(size);
std::vector<int> arr(size);

int main() {
    std::cout << T::arr.size() << "\n";     // 50
    std::cout << arr.size() << "\n";        // 100

    return 0;
}
```

有限定名字查找可用于访问被嵌套声明或被隐藏的类成员，且对有限定的成员函数的调用绝不涉及多态（虚调用）。

```cpp
struct T {
    static constexpr int i = 10;
};

struct B : public T {
    static constexpr int i = 20;
};

int main() {
    std::cout << B::i << "\n";      // 20
    std::cout << B::T::i << "\n";   // 10

    return 0;
}
```

###### 命名空间成员

如果`::`左侧的名字代表命名空间或者为空（全局命名空间），那么`::`右侧的名字就会在该命名空间中查找，但存在以下例外：

>   1.   在模板实参中使用的名字，默认会在当前作用域中开始查找。
>
>        ```cpp
>        namespace N{
>            template<size_t I>
>            auto call() -> void{
>                std::cout << I << "\n";
>            }
>             
>            constexpr size_t i  = 10;
>        }
>             
>        constexpr size_t i = 20;
>             
>        int main() {
>            N::call<i>();       // 20
>            N::call<N::i>();    // 10
>             
>            return 0;
>        }
>        ```