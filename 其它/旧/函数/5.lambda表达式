* C++11引入`lambda`表达式。其实质是一个匿名、重载了`operator()`的类的实例。

* 捕获列表为空的`lambda`对象，其大小为1字节。

  捕获列表不为空的`lambda`对象，其大小将由其捕获列表决定。

----

#### 捕获列表

* 被捕获的对象必须是非静态的局部变量。

* 值捕获：`[捕获对象]`。

   * 在`lambda`创建时，将拷贝一份捕获对象。

   * `lambda`是一个常量对象，默认通过值捕获的对象无法修改；在参数列表后声明`mutable`后，可移除`lambda`对象的常量属性。

     ```cpp
     auto lam = []() mutable {};
     ```

* 引用捕获：`[&捕获对象]`。

* 隐式捕获：编译器将根据`lambda`中的代码，推断需要捕获的对象。
  
   * `[=]`：值捕获。
   * `[&]`：引用捕获。


----

#### 参数

* `lambda`可以具有无名形参，但不能具有默认实参。
* C++14开始，`lambda`的参数类型可以由`auto`进行推断。

---

#### 广义捕获

* C++14引入了广义捕获，其使得`lambda`表达式可以捕获表达式，以及自定义捕获变量名：

    ```cpp
    int main()
    {
        int a = 10;
        [r = a * a]() {
            std::cout << r; // 100
        }();
    
        return 0;
    }
    ```
    
* 这使得`lambda`在捕获时，可以使用移动语义来提高效率。

    同时，还可以拷贝一份局部对象，在进行异步操作时，不会因为局部对象的释放产生未定义行为。

* 还可以将常量赋值给捕获变量：

    ```cpp
    int main()
    {
        auto lam = [i = 0]() mutable {return ++i;};
        std::cout << lam() << std::endl;		//1
        std::cout << lam() << std::endl;		//2
        std::cout << lam() << std::endl;		//3
        
        return 0;
    }
    ```


---

#### 捕获this

* C++17强化了捕获`this`，`[*this]`可得到当前作用域的`this`对象的拷贝

---

#### 模板

* C++20添加了模板对`lambda`的支持：

  ```cpp
  [] <typename T> (const T& t) {};
  ```

----

#### 捕获局部变量的陷阱

* 使用引用捕获局部变量时，如果局部变量被释放，而`lambda`表达式还在运行，将导致程序崩溃。