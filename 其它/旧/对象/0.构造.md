

###### 转换构造函数

不使用`explicit`声明的构造函数即为转换构造函数，转换构造函数可以用于直接初始化和复制初始化。









###### 构造

`cv`限定符声明的对象在构造函数调用之后才会拥有`cv`属性。









构造对象的过程：
1. 为该对象分配一块空间。
2. 如果空间地址不为`nullptr`，调用构造函数初始化这块空间。

以函数形式构造对象时，参数表达式计算顺序不定；以列表初始化方式构造时，参数表达式从左往右计算。

```cpp
struct A
{
    A(int i) { std::cout << i; }
};

int main()
{
    std::tuple t1(A{0}, A{1});  // gcc : 10；clang : 01
    std::cout << "\n";
    std::tuple t2{A{0}, A{1}};  // 01

    return 0;
}
```

###### 默认构造函数

不需要参数、或所有参数都具有默认值的构造函数，就是默认构造函数。

类可以定义多个默认构造函数。但如果使用默认构造的方式创建对象，将报错。

###### 合成构造函数

当编译器需要默认构造函数，但未定义时，编译器会自动合成一个默认构造函数。以下情况会合成默认构造：
1. 对象成员具有默认构造函数（包含合成的默认构造）。
2. 基类具有默认构造函数。
3. 具有虚函数（编译器需要插入代码，以初始化虚指针）。
4. 继承链中有虚继承（编译器需要插入代码，以初始化虚基类指针）。
5. 使用`=default`显示让编译器合成。

合成的构造函数不会初始化内置类型和复合类型成员。

###### 初始化列表

只有在初始化列表中进行的才是初始化操作，构造函数体中的操作属于赋值。所以常量成员只能在初始化列表中进行初始化。

初始化列表只负责初始化的值，初始化顺序与在类中定义的顺序一致。

###### 委托构造

在初始化列表中可以调用自身或基类的构造函数，且使用委托调用后，初始化列表中只能存在该调用作为唯一的成员初始化器。

循环调用委托构造属于未定义行为，且编译器不一定会做检测。

###### 转换构造函数

可以只接受一个参数的构造函数，定义了将其他类型数据转换为该类的机制。默认支持隐式转换，使用`explicit`关键字，只支持显示调用。

对于隐式转换，编译器只会进行一步转换。

```cpp
struct A
{
    A(int) {}
};

struct B
{
    B(A) {}
};

int main()
{
    B b1 = 1;		// 隐式转换失败
    B b2(1);		// 显示转换成功
    return 0;
}
```

###### 继承构造函数

在派生类中使用`using`声明基类的构造函数，当派生类中不存在基类构造函数参数匹配的构造函数时，编译器将会合成与基类构造函数参数匹配的构造函数。

该声明不会改变构造函数的访问权限。

```cpp
struct Base
{
    Base(int)
    {
        std::cout << "Base(int)" << std::endl;
    }
};

struct Derive
{
    using Base::Base;
};

int main()
{
    Derive(0); // Base(int)
    return 0;
}
```
