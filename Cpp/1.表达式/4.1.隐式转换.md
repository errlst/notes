在语境中使用T1类型的表达式，但该语境需要接受另一T2类型时，会进行隐式类型转换。

#### 转换顺序
隐式转换的顺序如下：
1. 零或一个 _标准转换_。
2. 零或一个 _用户定义转换_。
3. 零或一个 _标准转换_。
> 当考虑转换构造函数实参时，则只会进行一次 _标准转换_；当从一个非类类型转换到另一个非类类型时，也只会进行一次 _标准转换_。

#### 标准转换
###### 转换顺序
标准转换的顺序如下：
1. 零或一个 _值变换_。
2. 零或一个 _数值提升_ 或 _数值转换_。
3. 零或一个 _函数指针转换_。
4. 零或一个 _限定转换_。

###### 值变换
值变换是更改表达式值类别的转换，即从左值到右值的转换。

任何非函数、非数组类型 T 的泛左值都可以转换为纯右值。如果 T 不是类类型，那么纯右值的类型无cv限定。

###### 数值提升
数值提升包括整数提升、枚举提升和浮点提升。

数值提升不会改变值，不存在精度损失的问题。

###### 数值转换
数值转换包括整数转换、浮点转换、浮点整数转换、指针转换、不二转换等。

数值转换可能修改值，存在精度损失的风险。

###### 函数指针转换
指向无抛出函数的指针类型的纯右值，可转换成指向潜在抛出函数的指针纯右值。
```cpp
auto func_may_throw() -> void {}

auto func_no_throw() noexcept -> void {}

auto main() -> int {
    using func_may_throw_t = void();
    func_may_throw_t* p1 = func_may_throw;
    func_may_throw_t* p2 = func_no_throw;

    using func_no_throw_t = void() noexcept;
    func_no_throw_t* p3 = func_may_throw;   // error
    func_no_throw_t* p4 = func_no_throw;
    return 0;
}
```

指向无抛出成员函数指针类型的纯右值，可转换成指向潜在抛出成员函数的指针纯右值。

###### 限定转换
指向 T 的指针类型的纯右值，可以转换为指向拥有更多cv限定的 T 的指针类型的纯右值。即cv限定更少的，可以转换为cv限定更多的。