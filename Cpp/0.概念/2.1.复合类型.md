#### 引用类型

###### 初始化

引用并不是对象（为了实现引用，编译器实现通常占据指针大小的空间），因此初始化引用时，必须将其绑定到对象上，且不能再次绑定。

对 _T_ 的引用，可以绑定到 _T_ 类型对象、_T_ 类型函数，或可隐式转换为 _T_ 类型的对象。

初始化非常量左值引用时：

* 如果目标是左值表达式，且其是T类型或T的派生类型，且存在相等或更少的cv限定，引用绑定到表达式对象或其基类子对象。

* 如果目标拥有到T类型或T的派生类型的类型转换函数，引用绑定到转换函数返回的对象。

  ```cpp
  struct T {
      static inline int i = 0;
      operator int& () { return i; }
  };
  
  auto main() -> int {
      int& ref = T{};     // 绑定到 T::i
      ref = 20;
      std::cout << T::i;  // 20
      return 0;
  }
  ```

###### 延迟生命周期

初始化常量左值引用或右值引用时，如果绑定到临时对象或其子对象，将延长临时对象的生命周期，以匹配引用的生命周期。

但上述规则存在一下例外：

* 函数返回其局部对象或子对象的引用时，其生命周期不会延续，且返回悬垂引用。

* 在函数调用时，绑定到函数参数的临时量，其生存周期延续到函数调用的全表达式结尾（`;`）。

  ```cpp
  struct T { ~T() { std::cout << "destruct\n"; } };
  
  auto call1(const T&) { std::cout << "call1\n"; return 0; }
  
  auto call2() { std::cout << "call2\n"; return 0; }
  
  auto main() -> int {
      call1(T{}) || call2();  // call1 + call2 + destruct
      return 0;
  }   
  ```

* 初始化具有引用成员的聚合体时：

  * 如果使用直接初始化 _()_，不会延长生命周期。
  * 如果使用列表初始化 _{}_，会延长生命周期。

  ```cpp
  struct T { ~T() { std::cout << "destruct\n"; } };
  
  struct U { T&& ref; };
  
  auto main() -> int {
      {
          U u(T{});   // destruct
          std::cout << "----------\n";
      }
      U u{ T{} };
      std::cout << "----------\n";
  
      return 0;
  }   // destruct
  ```

  总之，临时量的生存周期不能通过进一步传递来延续。

#### 指针类型

任何类型的指针都可隐式转换为空指针，但逆向转化必须显示进行。

###### 数据成员指针

指向类 `Class` 的类型为 `Type` 的数据成员的指针，其类型可表示为 `Type(Class::*)`。

数据成员指针的通常实现为数据成员在类结构中的偏移量。

###### 成员函数指针

指向类 `Class` 的类型为 `Ret(Args...)` 的成员函数的指针，其类型可表示为 `Ret(Class::*)(Args...)`。

成员函数指针可以作为普通函数指针调用，其第一个参数作为 `this` 指针。

###### nullptr

`nullptr` 是 `nullptr_t` 类型的纯右值对象，其并非指针类型，且 `is_pointer_v<nullptr_t>` 为假。但 `nullptr_t` 可以转换为空指针类型或空成员指针类型。

#### 数组类型

###### 未知边界数组

声明数组时，只有第一个维度可以是未指定边界的。但可以初始化绑定到未知边界数组的引用或指针，且c++20允许使用已知边界的数组对其进行初始化。

```cpp
auto main() -> int {
    int arr[1];
    int(&ref)[] = arr;  // c++20 ok
    int(*ptr)[] = &arr; // c++20 ok
    return 0;
}
```

###### 数组纯右值

数组无法通过函数按值返回，且不能作为大多数转型表达式的目标类型，但可以通过类型别名的方式、并使用 `{}` 初始化构造数组纯右值，且会发生临时量实质化。

```cpp
auto main() -> int {
    struct T{};
    using TArr = T[2];
//  TArr(); error
    TArr{}; // ok
    return 0;
}
```

###### 字符串字面量

字符串字面量的类型为 `const CharT[N]`。默认字符串字面量是 `char` 类型字符序列，使用 `u8`、`u` 和 `U` 前缀表示 `char8_t`、`char16_t` 和 `char32_t` 类型字符序列。

字符串字面量是否会存储到不重叠的对象属于未定义行为，连续求值相同的字符串字面量是否会产生不同的字符串对象也是未定义行为。

```cpp
auto main() -> int {
    // gcc、msvc输出false，clang输出true
    std::cout << ("lo" == (3 + "hello"));	
    return 0;
}
```

###### 原始字符串字面量

在字符串字面量类型前缀后加上 `R` 前缀，表示当前字面量为原始字符串字面量。在原始字符串中，转义字符被解析为普通字符，且其定义可以跨越任意行。

为了指明原始字符串的边界，需要在字符串两端加上 `边界(` 和 `)边界`，边界可以是任意字符串。原始字符串的完整形式为 `R"边界(内容)边界"`。