无限定名字查找按照下述规则检查各个作用域，并在找到第一个声明时就不再检查其他作用域。

#### 命名空间内定义

在命名空间中，在任何函数或类之外使用的名字，首先查找其定义之前的部分，然后查找外层命名空间中在其之前的部分，依此类推直到全局命名空间。

#### 命名空间外定义

声明在某个命名空间中的名字，在命名空间外定义，同命名空间内定义类似，但查找定义之前的部分，而不是声明前的部分。

```cpp
namespace N {
    extern int x;
    int i = 0;    // 第一个被查找
}

int i = 1;        // 第二个被查找

int N::x = i;     // N::x = 0
```

#### 默认实参

在函数声明的默认实参、或构造函数成员初始化器的表达式中使用的名字，会先查找函数形参中已出现的名字，然后再向外查找。

```cpp
struct T {
    T(int i) : a{i}, b{this->i}, i{i} {}    // a和i初始化为形参i的值
                                            // b初始化为T::i的值
    int a, b, i;
};


int i;
auto call(int i, int j = i);    // error：对i的查找结果为形参i，而非::i
                                // 但在默认实参中不允许使用形参
```

#### 模板定义

对于在模板定义中使用的非待决名，在检查该模板的定义时会进行无限定名字查找，并绑定。

对于在模板定义中使用的待决名，其名字查找将推迟直到得到该模板的实际参数，此时：

- 实参依赖查找将同时在模板的定义语境和模板的实例化语境中查找可见的函数声明。

- 非实参依赖查找只会在模板的定义语境中查找可见的函数声明。

即：在模板定义后添加新的函数声明，除非通过实参依赖查找，否则依然不可见。如果某个基类取决于某个模板形参，那么无限定名字查找不会检查其作用域。

```cpp
template<typename T>
struct Base {
    auto call() -> void { std::cout << "Base::call()\n"; }
};

auto call() -> void { std::cout << "::call()\n"; }

template<typename T>
struct Derive : public Base<T> {
    auto c() -> void { call(); }
};

auto main() -> int {
    Derive<void>{}.c(); // ::call()

    return 0;
}
```
