不使用『构造器』初始变量时，进行[默认初始化]()。『默认初始化』会在以下情况进行：

* 不带初始化器声明的具有[自动存储期]()、[静态存储期]()或[线程存储期]()的对象。
* 不带初始化器的[new表达式]()创建具有[动态存储期]()的对象。
* [构造函数初始化列表]()中未提及某个基类或非静态数据成员，且调用该构造时，[默认初始化]()基类或非静态数据成员。[示例](#示例1)

『默认初始化』的结果是：

* 如果T是类类型，参考上述最后一点。
* 如果T是数组类型，默认初始化数组所有元素。
* 否则，不做任何处理[^1]。

#### const可默认构造

如果类类型T的[默认初始化]()调用用户提供的构造函数，或满足以下条件，则T及其数组是『const可默认构造』的：[^2]

* T的所有『非静态数据成员』M均拥有默认初始化器，或M为『const可默认构造』。
* 如果T是『联合体』，其刚好有一个『非静态变体成员』拥有默认初始化器。
* T的所有潜在构造基类都是[const可默认构造]的。

# 示例

```cpp
struct T {
	T() { std::println("default construct\n"); }
	T(int) { std::println("int construct\n"); }
	auto operator=(const T&) { std::println("copy operator"); }
};

struct U {
	U() {
		t = 0; // 此处通过构造函数创建临时T对象，然后赋值给t
	}

	T t;
};


auto main() -> int {
	U u;	// default construct + int construct + copy operator

	return 0;
}
```

[^1]:具有[自动存储期]()的对象初始化为不确定值。
[^2]:主流编译器对该特性的支持并不完全符合标准

