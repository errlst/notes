初始化除了在定义变量时进行，还会在函数参数传递和函数返回时发生。

#### 初始化器
有效的初始化器包括：
* **复制初始化**。`= 表达式`。
* **列表初始化**。`= {}`、`= {初始化器列表}`、`= {指派初始化器列表}`、`{}`、`{初始化器列表}`、`{指派初始化器列表}`。
* **直接初始化**。`(初始化器列表)`。

其中：
* 初始化器子句必须是：表达式、`{}`、`{初始化器列表}` 或 `{指派初始化器列表}`。
* 指派初始化器列表的语法为 `{.成员1 = xxx, .成员2 = xxx}`，且成员1必须在成员2之前声明。

如果没有为对象提供初始化器，将进行**默认初始化**。

#### 初始化
###### 复制初始化
函数调用时实参传递、函数返回值、`throw`、`catch` 都会进行复制初始化，其效果为：
* 如果T是类类型，且初始化器是同类型（忽略cv）的纯右值表达式，那么会进行复制消除。
* 否则，如果T是类类型，且其他对象的类型是T类型（忽略cv）或T的派生类，那么检测T的非显示构造函数，并进行重载决议。
* 否则，如果T是类类型，且其他对象的类型与T无关；或T是非类类型，其他对象是类类型，那么检测是否存在从其他对象类型到T类型的用户定义转换序列，并进行重载决议。
* 否则，即T和其他对象均为非类类型，通过标准转换将其他对象转换为T的无cv版本。

###### 列表初始化

###### 默认初始化
默认初始化是没有为对象提供初始化器时进行，其包括 `T 对象` 和 `new T` 两种语法。其效果为：
* 如果T是类类型，重载调用默认构造函数，进行初始化。
* 如果T是数组类型，对数组的所有元素进行默认初始化。
* 否则，不进行初始化。



#### 非局部变量初始化

所有具有[静态存储期]()的『非局部变量』的初始化会作为程序启动的一部分，在入口函数调用前进行[^1]。所有具有[线程局部存储期]()的『非局部变量』的初始化会作为线程启动的一部分进行，[按序早于]()线程函数的执行开始。

###### 静态初始化

如果『静态初始化』不进行[常量初始化]()，则进行[零初始化]()。『静态初始化』在任何『动态初始化』之前进行。

通过[零初始化]()的对象，也可以进行[动态初始化]()。[示例](#示例1)

###### 动态初始化

在『静态初始化』完成后，会在以下情形中进行『非局部变量』的动态初始化：

* 『无序的动态初始化』。对于『隐式特化』的『类模板的静态数据成员』以及『变量模板』，相对于其它动态初始化之间的顺序是不确定的。
* 『部分有序的动态初始化』。
* 『有序的动态初始化』。

###### 提早动态初始化

在满足以下条件的情况下，允许编译器将『动态初始化的变量』『静态初始化』：[示例](#示例2)

* 动态初始化不会改变作用域中任何『先于其初始化的对象』的值。
* 通过动态初始化的值恒定。

###### 延迟动态初始化

# 示例

###### 示例1

```cpp
static int i = [] {
	std::println("{}", i);	// i零初始化为0
	return 1;
	}();

auto main() -> int {
	std::println("{}", i);	// i动态初始化为1

	return 0;
}
```

###### 示例2

```cpp
namespace N1 {
	extern int i1;
	int i2 = i1;	// i1动态初始化，i2为0
	int i1 = [] {
		std::println("");
		return 1;
		}();
}

namespace N2 {
	extern int i1;
	int i2 = i1;	// i1提早为静态初始化，i2为1
	int i1 = []() {
		return 1;
		}();
}

auto main() -> int {
	std::println("{}", N1::i2);	// 0
	std::println("{}", N2::i2);	// 1

	return 0;
}
```



[^1]:除非被[延迟初始化]()