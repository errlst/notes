## 成员说明

类内部可以存在以下任意类型的成员说明：

* 具有如下形式的成员声明：『`属性[可选] 声明说明符序列[可选] 成员声明符序列[可选]`』。
  可以声明[数据成员]()、[成员函数]()、[类型别名]()、[成员枚举]()、[嵌套类]()、[友元声明]()。
* 函数定义。同时声明并定义[成员函数]()或[友元函数]()，且自动声明为[内联]()的。
* 访问说明符。
* [static_assert]()声明。[示例](#示例1)
* 成员类模板的[推导指引]()。

## 局部类

定义在函数体内部的称为[局部类]()，其存在以下限制：

* 不能拥有[静态数据成员]()、[成员模板]()、[友元模板]()。
* [成员函数]()必须在类内部定义，且[无链接]()。
* 不能在类内部定义[友元函数]()，但可以声明。[示例](#示例2)

## 嵌套类

定义在其他类内部的称为[嵌套类]()，且嵌套类服从[访问权限]()。

嵌套类默认是其『外部类』的[友元类]()，但嵌套类中的友元不是其外部类的友元。[示例](#示例4)

嵌套类成员的类外定义需要在外部类的命名空间中，且嵌套类可以前置声明，在外部类的命名空间中后定义。[示例](#示例5)

## 联合体

联合体是任意时刻只能保证一个[非静态数据成员]()活跃的特殊类类型，其具有以下限制：

* 不能拥有[虚函数]()，不能作为基类，且不能拥有基类。
* 不能拥有[引用类型]()的[非静态数据成员]()。
* 最多只有一个[变体成员]()可以拥有[默认初始化器]()。
* 如果拥有[非平凡特殊成员函数]()[^1]的[非静态数据成员]()，该联合体的[默认构造函数]()被弃置，除非存在变体成员拥有[默认初始化器]()。[示例](#示例3)

### 尺寸

联合体的大小保证能存放其最大的[变体成员]()，『其它变体成员』共享『最大变体成员』的内存，但具体分配细节由实现定义。

# 示例

## 示例1

```cpp
template<typename T>
struct U {
    static_assert(std::is_integral_v<T>, "U<T>: T must integer");
};

auto ok = U<int>{};
auto error = U<float>{};  // error
```

## 示例2

```cpp
auto main() -> int {
    class {
        friend auto ::main() -> int;
        auto call() { std::cout << "call\n"; }
    } t;
    t.call(); // call

    return 0;
}
```

## 示例3

```cpp
union U1 {
    std::string str;
    ~U1() {}
};

union U2 {
    std::string str{""};
    ~U2() {}
};

auto main() -> int {
    U1 u1;    // error
    U1 u1_{};
    U2 u2;

    return 0;
}
```

## 示例4

```cpp
auto main() -> int {
    class O {
        class I {
            friend auto::main() -> int;
        };
        int i;
    }o;
    std::cout << o.i;   // error，o.i is private

    return 0;
}
```

## 示例5

```cpp
struct O {
    struct I;
};

struct O::I {
    auto call() -> void;
};

auto O::I::call() -> void {}
```





[^1]:拥有[复制控制函数]()、[移动控制函数]()或[析构函数]()