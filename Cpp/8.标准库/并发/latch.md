#### latch

`latch` 是向下计数器，在创建时为其设置初始值，线程可在其上阻塞直到计数器减少为0。除了析构函数，`latch` 是线程安全的，且只能进行一次完整的计数流程。

###### 控制

`.count_down(n=1)`，原子减少计数器的值，如果 _n_ 大于等于当前计数器的值，或为负数，行为未定义。

`.try_wait()`，测试计数器是否抵达零。存在极小概率，计数器已经抵达零，但返回 `false`。

`.wait()`，阻塞直到计数器抵达零。

`.arrive_and_wait(n)`，原子减少计数器的值，然后等待。

---

#### barrier

`barrier` 类似与 `latch`，但其可以重复使用，且在抵达零后，进行回调操作，且恢复到初始计数。

###### 构造

`barrier(n, f)`，构造时可额外提供回调对象。

###### 操作

`.arrive(n)`，减少当前计数，且返回 `arrival_token` 对象。

`.wait(token)`，行为依赖于 _token_：

* 如果 `token` 和 _this_ 的当前阶段关联，则阻塞直到当前阶段抵达零。
* 如果 `token` 和 _this_ 的上一个阶段关联，则立即返回。
* 否则，行为未定义。

`.arrive_and_wait()`，当前计数减1，且等待当前阶段抵达零，等价 `wait(arrive())`。如果当前阶段已经抵达零，行为未定义。

`.arrive_and_drop()`，当前计数和初始计数均减1。同上。