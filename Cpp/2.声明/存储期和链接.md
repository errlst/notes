#### 存储类说明符
存储类说明符控制名字的存储期和链接。
* 无说明符，自动存储期。
* `static`，静态或线程存储期，内部链接。
* `extern`，静态或线程存储期，外部链接。
* `thread_local`，线程存储期。

一条声明中通常只能出现一个存储类说明符，但 `thread_local` 可以和 `static` 或 `extern` 结合。

#### 存储期
自动存储期：对象在其所处作用域开始时分配，结束时释放。

静态存储期：对象在程序开始时分配，程序结束时释放。整个程序中只能存在一个实例。

线程存储期：对象在线程开始时分配，线程结束时释放。每个线程中存在一个实例。

动态存储期：通过 `new` 创建的对象、隐式创建的对象、以及异常对象拥有该存储期，这些对象：
* 如果通过 `new` 创建，使用动态内存分配函数进行分配释放。
* 如果是异常对象，使用未指定方式进行分配释放。
* 如果是隐式创建的对象，与某个已存在对象重叠。

#### 链接
链接属性用于判断不同编译单元中，相同的名字是否指代同一个实体。

###### 无链接

无链接的名字只能在其作用域中使用，在块作用域中声明的以下任何名字均是无链接的：

* 未显示声明为 `extern` 的变量。

  ```cpp
  int i = 10;
  
  auto call_1() {
      int i;  // 局部变量i
      std::cout << i << "\n";
  }
  
  auto call_2() {
      static int i;  // 局部静态变量i
      std::cout << i << "\n";
  }
  
  auto call_3() {
      extern int i;  // 链接为全局i
      std::cout << i << "\n";
  }
  
  auto main() -> int {
      call_1();
      call_2();
      call_3();
  
      return 0;
  }
  ```

* 局部类和其成员函数。

* 声明的其他名字，如 `typedef`、枚举。

###### 内部连接

具有内部连接的名字只在当前编译单元中使用，在命名空间作用域中定义的下列名字均是内部链接的：

* 具有 `const` 限定，没有 `volatile` 限定的非模板变量，且不是内联、没有声明为 `extern`。

* `匿名联合体` 的数据成员。

  ```cpp
  ////////////////////////////////////////////// main.cc
  union {
  	int i;
  }anonymous;
  
  auto call() -> void;
  
  auto main() -> int {
  	anonymous.i = 10;
  	call(); // anonymouse.i = 0
  
  	return 0;
  }
  
  ////////////////////////////////////////////// test.cc
  union {
  	int i;
  }anonymous;
  
  auto call() -> void {
  	std::println("anonymouse.i = {}", anonymous.i);
  }
  ```

###### 外部链接

具有外部链接的名字在多个编译单元中指代同一个实体，在命名空间作用域中的下列名字均是外部链接的：

* 非 `static` 函数、非 `static` 的非 `const` 变量。
* 声明为 `extern` 的变量。
* 枚举。
* 类及其成员函数、静态数据成员、嵌套类、枚举。

首次在块作用域中声明的下列名字也具有外部链接：

* 声明为 `extern` 的变量。
* 函数。

#### 静态局部变量

在块作用域中声明的 `static` 变量，只有首次经过声明时才会初始化。

* 如果初始化抛出异常，下次经过该声明时会再次初始化。

  ```cpp
  bool flag{false};
  
  struct T {
      T() {
          std::println("construct");
          if(!flag && (flag = true)){
              throw 0;
          }
      }
  };
  
  auto call() -> void try {
      static T t;
  } catch (...) { }
  
  auto main() -> int {
      call();  // construct
      call();  // construct
      call();  // no output
  
      return 0;
  }
  ```

* 如果通过递归的方式初始化，行为未定义。

* 如果多个线程尝试同时初始化同一个静态局部变量，初始化也只会发生一次。

#### 占位符变量

c++26，如果声明的名称是 `_`，且具有自动存储期、没有显示类型说明、带有初始化器，那么其是占位符变量，其自带 `[[maybe_unused]]` 属性，且无法被使用。

可以用在结构化绑定中，占位不需要的元素。