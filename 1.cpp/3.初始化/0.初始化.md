初始化除了在定义变量时进行，还会在函数参数传递和函数返回时发生。

#### 初始化器
有效的初始化器包括：
* **复制初始化**。`= 表达式`。
* **列表初始化**。`= {}`、`= {初始化器列表}`、`= {指派初始化器列表}`、`{}`、`{初始化器列表}`、`{指派初始化器列表}`。
* **直接初始化**。`(初始化器列表)`。

其中：
* 初始化器子句必须是：表达式、`{}`、`{初始化器列表}` 或 `{指派初始化器列表}`。
* 指派初始化器列表的语法为 `{.成员1 = xxx, .成员2 = xxx}`，且成员1必须在成员2之前声明。

如果没有为对象提供初始化器，将进行**默认初始化**。

如果为对象指定初始化器为 `()`（由于语法和函数声明语法冲突，因此不能出现在声明符中），将进行**值初始化**。

#### 默认初始化
默认初始化是没有为对象提供初始化器时进行，其包括 `T 对象` 和 `new T` 两种语法。

其效果为：
* 如果T是类类型，重载调用默认构造函数，进行初始化。
* 如果T是数组类型，对数组的所有元素进行默认初始化。
* 否则，不进行初始化。

#### 非局部变量初始化

所有具有[静态存储期]()的『非局部变量』的初始化会作为程序启动的一部分，在入口函数调用前进行[^1]。所有具有[线程局部存储期]()的『非局部变量』的初始化会作为线程启动的一部分进行，[按序早于]()线程函数的执行开始。

###### 静态初始化

如果『静态初始化』不进行[常量初始化]()，则进行[零初始化]()。『静态初始化』在任何『动态初始化』之前进行。

通过[零初始化]()的对象，也可以进行[动态初始化]()。[示例](#示例1)

###### 动态初始化

在『静态初始化』完成后，会在以下情形中进行『非局部变量』的动态初始化：

* 『无序的动态初始化』。对于『隐式特化』的『类模板的静态数据成员』以及『变量模板』，相对于其它动态初始化之间的顺序是不确定的。
* 『部分有序的动态初始化』。
* 『有序的动态初始化』。

###### 提早动态初始化

在满足以下条件的情况下，允许编译器将『动态初始化的变量』『静态初始化』：[示例](#示例2)

* 动态初始化不会改变作用域中任何『先于其初始化的对象』的值。
* 通过动态初始化的值恒定。

###### 延迟动态初始化

# 示例

###### 示例1

```cpp
static int i = [] {
	std::println("{}", i);	// i零初始化为0
	return 1;
	}();

auto main() -> int {
	std::println("{}", i);	// i动态初始化为1

	return 0;
}
```

###### 示例2

```cpp
namespace N1 {
	extern int i1;
	int i2 = i1;	// i1动态初始化，i2为0
	int i1 = [] {
		std::println("");
		return 1;
		}();
}

namespace N2 {
	extern int i1;
	int i2 = i1;	// i1提早为静态初始化，i2为1
	int i1 = []() {
		return 1;
		}();
}

auto main() -> int {
	std::println("{}", N1::i2);	// 0
	std::println("{}", N2::i2);	// 1

	return 0;
}
```



[^1]:除非被[延迟初始化]()